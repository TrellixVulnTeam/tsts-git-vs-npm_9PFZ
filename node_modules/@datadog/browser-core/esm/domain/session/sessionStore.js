import { __assign } from "tslib";
import { cacheCookieAccess, COOKIE_ACCESS_DELAY } from '../../browser/cookie';
import { Observable } from '../../tools/observable';
import * as utils from '../../tools/utils';
import { monitor } from '../internalMonitoring';
export var SESSION_COOKIE_NAME = '_dd_s';
export var SESSION_EXPIRATION_DELAY = 15 * utils.ONE_MINUTE;
export var SESSION_TIME_OUT_DELAY = 4 * utils.ONE_HOUR;
var SESSION_ENTRY_REGEXP = /^([a-z]+)=([a-z0-9-]+)$/;
var SESSION_ENTRY_SEPARATOR = '&';
export function startSessionStore(options, productKey, computeSessionState) {
    var renewObservable = new Observable();
    var sessionCookie = cacheCookieAccess(SESSION_COOKIE_NAME, options);
    var inMemorySession = retrieveActiveSession(sessionCookie);
    var expandOrRenewSession = utils.throttle(monitor(function () {
        sessionCookie.clearCache();
        var cookieSession = retrieveActiveSession(sessionCookie);
        var _a = computeSessionState(cookieSession[productKey]), trackingType = _a.trackingType, isTracked = _a.isTracked;
        cookieSession[productKey] = trackingType;
        if (isTracked && !cookieSession.id) {
            cookieSession.id = utils.generateUUID();
            cookieSession.created = String(Date.now());
        }
        // save changes and expand session duration
        persistSession(cookieSession, sessionCookie);
        // If the session id has changed, notify that the session has been renewed
        if (isTracked && inMemorySession.id !== cookieSession.id) {
            inMemorySession = __assign({}, cookieSession);
            renewObservable.notify();
        }
        inMemorySession = __assign({}, cookieSession);
    }), COOKIE_ACCESS_DELAY).throttled;
    function expandSession() {
        sessionCookie.clearCache();
        var session = retrieveActiveSession(sessionCookie);
        persistSession(session, sessionCookie);
    }
    function retrieveSession() {
        return retrieveActiveSession(sessionCookie);
    }
    return {
        expandOrRenewSession: expandOrRenewSession,
        expandSession: expandSession,
        retrieveSession: retrieveSession,
        renewObservable: renewObservable,
    };
}
function isValidSessionString(sessionString) {
    return (sessionString !== undefined &&
        (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString)));
}
function retrieveActiveSession(sessionCookie) {
    var session = retrieveSession(sessionCookie);
    if (isActiveSession(session)) {
        return session;
    }
    clearSession(sessionCookie);
    return {};
}
function isActiveSession(session) {
    // created and expire can be undefined for versions which was not storing them
    // these checks could be removed when older versions will not be available/live anymore
    return ((session.created === undefined || Date.now() - Number(session.created) < SESSION_TIME_OUT_DELAY) &&
        (session.expire === undefined || Date.now() < Number(session.expire)));
}
function retrieveSession(sessionCookie) {
    var sessionString = sessionCookie.get();
    var session = {};
    if (isValidSessionString(sessionString)) {
        sessionString.split(SESSION_ENTRY_SEPARATOR).forEach(function (entry) {
            var matches = SESSION_ENTRY_REGEXP.exec(entry);
            if (matches !== null) {
                var key = matches[1], value = matches[2];
                session[key] = value;
            }
        });
    }
    return session;
}
export function persistSession(session, cookie) {
    if (utils.isEmptyObject(session)) {
        clearSession(cookie);
        return;
    }
    session.expire = String(Date.now() + SESSION_EXPIRATION_DELAY);
    var cookieString = utils
        .objectEntries(session)
        .map(function (_a) {
        var key = _a[0], value = _a[1];
        return key + "=" + value;
    })
        .join(SESSION_ENTRY_SEPARATOR);
    cookie.set(cookieString, SESSION_EXPIRATION_DELAY);
}
function clearSession(cookie) {
    cookie.set('', 0);
}
//# sourceMappingURL=sessionStore.js.map