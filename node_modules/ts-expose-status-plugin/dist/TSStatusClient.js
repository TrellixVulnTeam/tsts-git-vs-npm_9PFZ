"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var node_ipc_1 = tslib_1.__importDefault(require("node-ipc"));
var path_1 = require("path");
var Protocol_1 = require("./Protocol");
/**
 * Client code for communicating with ts-expose-status-plugin.
 *
 * This client exposes async methods for interfacing with the TS language service. With the current
 * implementation, only one simultaneous method call is allowed.
 */
var TSStatusClient = /** @class */ (function () {
    function TSStatusClient(ipc, connection) {
        var _this = this;
        this.ipc = ipc;
        this.connection = connection;
        // tslint:disable-next-line no-any
        this.responseCallback = null;
        // tslint:disable-next-line no-any
        this.connection.on(Protocol_1.RESPOND_EVENT, function (data) {
            if (_this.responseCallback == null) {
                throw new Error('Expected response callback to be set');
            }
            var callback = _this.responseCallback;
            _this.responseCallback = null;
            callback(data);
        });
    }
    TSStatusClient.withClient = function (_a) {
        var onSuccess = _a.onSuccess, onError = _a.onError;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var client, e_1, result;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.connect()];
                    case 1:
                        client = _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        e_1 = _b.sent();
                        return [2 /*return*/, onError(e_1)];
                    case 3:
                        _b.trys.push([3, , 5, 6]);
                        return [4 /*yield*/, onSuccess(client)];
                    case 4:
                        result = _b.sent();
                        return [3 /*break*/, 6];
                    case 5:
                        client.disconnect();
                        return [7 /*endfinally*/];
                    case 6: return [2 /*return*/, result];
                }
            });
        });
    };
    TSStatusClient.connect = function () {
        return new Promise(function (resolvePromise, rejectPromise) {
            var ipc = new node_ipc_1.default.IPC();
            ipc.config.id = 'ts-expose-status-plugin-client';
            ipc.config.silent = true;
            // Don't retry, since it's likely that a language service just isn't running.
            // maxRetries has a bad TS type, so work around using any.
            // tslint:disable-next-line no-any
            ipc.config.maxRetries = 0;
            ipc.connectTo(Protocol_1.SERVER_ID, function () {
                var connection = ipc.of[Protocol_1.SERVER_ID];
                connection.on('error', function (e) {
                    rejectPromise(e);
                });
                connection.on('connect', function () {
                    resolvePromise(new TSStatusClient(ipc, connection));
                });
            });
        });
    };
    TSStatusClient.prototype.disconnect = function () {
        this.ipc.disconnect(Protocol_1.SERVER_ID);
    };
    TSStatusClient.prototype.getAllErrors = function () {
        return this.call({ method: 'getAllErrors' });
    };
    TSStatusClient.prototype.getErrorsForFiles = function (filenames) {
        // We can't rely on the working directory of the TS language service, so make sure to convert
        // all filenames to absolute! If we don't do this, TSLint ends up not returning any errors.
        var absoluteFilenames = filenames.map(function (filename) { return path_1.resolve(filename); });
        return this.call({ method: 'getErrorsForFiles', filenames: absoluteFilenames });
    };
    // tslint:disable-next-line no-any
    TSStatusClient.prototype.call = function (payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.responseCallback != null) {
                            throw new Error('Expected responseCallback to be unset. May only make one concurrent call.');
                        }
                        return [4 /*yield*/, new Promise(function (resolvePromise) {
                                _this.responseCallback = resolvePromise;
                                _this.connection.emit(Protocol_1.CALL_EVENT, payload);
                            })];
                    case 1:
                        response = _a.sent();
                        if (typeof response === 'string') {
                            throw new Error("Error from TS language service: " + response);
                        }
                        return [2 /*return*/, response];
                }
            });
        });
    };
    return TSStatusClient;
}());
exports.default = TSStatusClient;
