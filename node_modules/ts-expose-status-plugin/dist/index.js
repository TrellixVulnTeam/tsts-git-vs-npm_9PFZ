"use strict";
var tslib_1 = require("tslib");
var node_ipc_1 = require("node-ipc");
var fs_1 = require("fs");
var os_1 = require("os");
var Protocol_1 = require("./Protocol");
var path_1 = require("path");
var LOG_FILE = os_1.homedir() + "/ts-expose-status-plugin-output.log";
var LOGGING_ENABLED = false;
/**
 * Log a message for debugging purposes.
 *
 * Rather than using the built-in info.project.projectService.logger.info() logging,
 * we append to a file in a hard-coded location. This makes it possible to save log
 * messages before a project has been set up (since the IPC handler is
 * project-independent) and avoids the need to pass a TSS_LOG env variable.
 */
function log(message) {
    if (LOGGING_ENABLED) {
        fs_1.appendFileSync(LOG_FILE, "(pid " + process.pid + ") " + new Date().toLocaleString() + ": " + message + "\n");
    }
}
/**
 * Typechecking helper for a single project.
 */
var ProjectChecker = /** @class */ (function () {
    function ProjectChecker(ts, info) {
        this.ts = ts;
        this.info = info;
    }
    ProjectChecker.prototype.convertToSimpleDiagnostic = function (diagnostic) {
        return {
            filePath: diagnostic.file ? path_1.resolve(diagnostic.file.fileName) : null,
            start: diagnostic.start != null ? diagnostic.start : null,
            end: diagnostic.start != null && diagnostic.length != null ? diagnostic.start + diagnostic.length : null,
            message: this.ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n'),
            code: diagnostic.code,
        };
    };
    ProjectChecker.prototype.getAllErrors = function () {
        var _this = this;
        var program = this.info.languageService.getProgram();
        if (!program) {
            return [];
        }
        // Ignore other diagnostic types for now, since they tend to not correspond to typical TS errors.
        var tsDiagnostics = tslib_1.__spread(program.getSemanticDiagnostics(), program.getSyntacticDiagnostics());
        return tsDiagnostics.map(function (diagnostic) { return _this.convertToSimpleDiagnostic(diagnostic); });
    };
    ProjectChecker.prototype.getErrorsForFile = function (filename) {
        var _this = this;
        return tslib_1.__spread(this.info.languageService.getSemanticDiagnostics(filename), this.info.languageService.getSyntacticDiagnostics(filename)).map(function (diagnostic) { return _this.convertToSimpleDiagnostic(diagnostic); });
    };
    ProjectChecker.prototype.fileInProject = function (filename) {
        var _a;
        return Boolean((_a = this.info.languageService.getProgram()) === null || _a === void 0 ? void 0 : _a.getSourceFile(filename));
    };
    return ProjectChecker;
}());
/**
 * Typechecking helper that combines results for all open projects.
 */
var MultiProjectChecker = /** @class */ (function () {
    function MultiProjectChecker() {
        this.projectCheckers = [];
    }
    MultiProjectChecker.prototype.registerProject = function (ts, info) {
        log("Initializing project " + info.project.projectName);
        this.projectCheckers.push(new ProjectChecker(ts, info));
    };
    MultiProjectChecker.prototype.getAllErrors = function () {
        return this.projectCheckers.flatMap(function (checker) { return checker.getAllErrors(); });
    };
    MultiProjectChecker.prototype.getErrorsForFiles = function (filenames) {
        var e_1, _a, e_2, _b;
        var diagnostics = [];
        try {
            for (var filenames_1 = tslib_1.__values(filenames), filenames_1_1 = filenames_1.next(); !filenames_1_1.done; filenames_1_1 = filenames_1.next()) {
                var filename = filenames_1_1.value;
                var matchedAnyProject = false;
                try {
                    // If we have multiple projects open, we don't know which project this
                    // file is in, so check each one for file membership and only check the
                    // one that passes so that we don't throw an exception for the others.
                    // It's also possible that the file is in multiple projects, which may
                    // give different error results (e.g. due to different tsconfig), so
                    // combine results from all projects in that case.
                    for (var _c = (e_2 = void 0, tslib_1.__values(this.projectCheckers)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var projectChecker = _d.value;
                        if (projectChecker.fileInProject(filename)) {
                            diagnostics.push.apply(diagnostics, tslib_1.__spread(projectChecker.getErrorsForFile(filename)));
                            matchedAnyProject = true;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                if (!matchedAnyProject) {
                    diagnostics.push({
                        filePath: filename,
                        start: null,
                        end: null,
                        message: "File " + filename + " was not found in any TypeScript project. Make sure the appropriate TypeScript project(s) are open in your editor.",
                        code: 20000,
                    });
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (filenames_1_1 && !filenames_1_1.done && (_a = filenames_1.return)) _a.call(filenames_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return diagnostics;
    };
    return MultiProjectChecker;
}());
var checker = new MultiProjectChecker();
var isIPCSetUp = false;
/**
 * One-time initialization of the IPC listener to communicate with a
 * TSStatusClient in a different process.
 */
function setupIPC() {
    var ipc = new node_ipc_1.IPC();
    ipc.config.id = Protocol_1.SERVER_ID;
    // We MUST silence logging, or else node-ipc will print to stdout. VSCode talks with the TS
    // language service over stdin/stdout, so any extraneous messages to stdout will break VSCode's
    // normal code intelligence features.
    ipc.config.silent = true;
    log("Starting ts-expose-status-plugin IPC server");
    ipc.serve(function () {
        ipc.server.on(Protocol_1.CALL_EVENT, function (data, socket) {
            log("Received method call: " + data.method);
            var response;
            try {
                if (data.method === 'getAllErrors') {
                    response = checker.getAllErrors();
                }
                else if (data.method === 'getErrorsForFiles') {
                    response = checker.getErrorsForFiles(data.filenames);
                }
                else {
                    var errorMsg = "Unexpected method: " + data.method;
                    log(errorMsg);
                    response = errorMsg;
                }
            }
            catch (e) {
                response = e.stack + "\n\n";
            }
            ipc.server.emit(socket, Protocol_1.RESPOND_EVENT, response);
        });
    });
    ipc.server.start();
}
/**
 * Extension point to initialize this plugin for a TS project. This function is
 * called once per project but we want to act on all projects at once, so we use
 * some module-level state to ensure that IPC is only set up once and to register
 * all projects that have been loaded.
 */
function init(modules) {
    if (!isIPCSetUp) {
        setupIPC();
        isIPCSetUp = true;
    }
    var ts = modules.typescript;
    return {
        create: function (info) {
            checker.registerProject(ts, info);
            return info.languageService;
        },
    };
}
module.exports = init;
